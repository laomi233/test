下面给你一个**完整思路**：在 AEM React SPA 项目里实现一个组件：

* **Author 端（对话框里）**：像 Excel 一样编辑表格（用第三方 JS 表格库，比如 Handsontable / AG Grid 之类）
* **前端 React 渲染**：只拿结构化数据（JSON）来渲染期望的表格样式，不把“Excel UI”带到 React 里

我按 AEM SPA archetype 的结构来写（`ui.apps / ui.content / ui.frontend`）。

---

## 0. 整体架构

**核心思路：**

1. 在组件对话框里，用自定义 clientlib + JS 初始化一个“Excel”表格 UI。
2. 表格的数据序列化成 JSON，存到一个 hidden/textarea 字段里，例如 `tableData`。
3. Sling Model 读出这个 `tableData` 属性，解析成 `List<List<String>>`，通过 SPA Exporter 输出成 JSON。
4. React SPA 组件通过 props 拿到 `tableData`，按你的设计渲染 `<table>`。

这样：

* “Excel 风格操作体验”只存在于 **author 对话框**；
* React 渲染只看干净的数据结构，不依赖 dialog 的 UI。

---

## 1. AEM 组件节点（ui.apps）

路径示例：

```text
/apps/my-site/components/content/excel-table
```

**`/.content.xml`：**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<jcr:root
    xmlns:sling="http://sling.apache.org/jcr/sling/1.0"
    xmlns:jcr="http://www.jcp.org/jcr/1.0"
    jcr:primaryType="cq:Component"
    jcr:title="Excel Table"
    componentGroup="My Site - Content"
    sling:resourceSuperType="wcm/foundation/components/parsys"> <!-- 也可以不继承，看你需求 -->
</jcr:root>
```

---

## 2. Dialog：内嵌 Excel 风格编辑器（ui.apps）

在组件下建 `/_cq_dialog/.content.xml`：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<jcr:root
    xmlns:sling="http://sling.apache.org/jcr/sling/1.0"
    xmlns:jcr="http://www.jcp.org/jcr/1.0"
    jcr:primaryType="nt:unstructured"
    sling:resourceType="cq/gui/components/authoring/dialog"
    extraClientlibs="[my-site.excel-table.author]"> <!-- 非常重要：加载我们自定义 clientlib -->
    
    <content
        jcr:primaryType="nt:unstructured"
        sling:resourceType="granite/ui/components/coral/foundation/container">
        <items jcr:primaryType="nt:unstructured">
            <tabs
                jcr:primaryType="nt:unstructured"
                sling:resourceType="granite/ui/components/coral/foundation/tabs">
                <items jcr:primaryType="nt:unstructured">
                    <basic
                        jcr:primaryType="nt:unstructured"
                        jcr:title="Table"
                        sling:resourceType="granite/ui/components/coral/foundation/container">
                        <items jcr:primaryType="nt:unstructured">

                            <!-- 实际存 JSON 的字段（隐藏起来） -->
                            <tableData
                                jcr:primaryType="nt:unstructured"
                                sling:resourceType="granite/ui/components/coral/foundation/form/textarea"
                                fieldLabel="Table Data (JSON)"
                                name="./tableData"
                                rows="5"
                                cols="40"
                                renderReadOnly="true"
                                />

                            <!-- 放一个 div 容器给我们的“Excel” UI 使用 -->
                            <tableEditor
                                jcr:primaryType="nt:unstructured"
                                sling:resourceType="granite/ui/components/coral/foundation/html"
                                tagName="div"
                                html="<div class='excel-table-editor' data-field-name='./tableData'></div>"/>
                        </items>
                    </basic>
                </items>
            </tabs>
        </items>
    </content>
</jcr:root>
```

这里：

* `./tableData` 是存 JSON 的字段；
* `excel-table-editor` 这个 div 是 JS 初始化 Handsontable / AG Grid 的挂载点。

---

## 3. Author 端 clientlib：Excel 编辑 UI（ui.apps）

路径示例：

```text
/apps/my-site/clientlibs/excel-table-author
```

**`/apps/my-site/clientlibs/excel-table-author/jcr:content`：**

```text
jcr:primaryType = cq:ClientLibraryFolder
categories = ["my-site.excel-table.author"]
allowProxy = true
dependencies = ["cq.authoring.dialog"]  // 确保 dialog 环境加载
```

### 3.1 css.txt / js.txt

```text
# css.txt
excel-table.css
```

```text
# js.txt
excel-table.js
```

你可以把第三方库打包进这里（或通过其他 clientlib 依赖），例如 Handsontable 的 js/css。

### 3.2 简化版 JS：用一个二维数组模拟“Excel”

下面示例不用真正引第三方库，只用简单 `<table>` + 点击/键盘编辑，方便你先打通流程。之后你可以把这段换成 Handsontable 的初始化代码。

**`excel-table.js`：**

```js
(function (document, $, Granite) {
  "use strict";

  function initExcelEditors() {
    // 找到我们在 dialog 中插入的 div
    $(".excel-table-editor").each(function () {
      var $container = $(this);
      var fieldName = $container.data("field-name"); // "./tableData"

      // 找到对应 textarea
      var $textarea = $("textarea[name='" + fieldName + "']");
      if ($container.data("initialized")) {
        return;
      }
      $container.data("initialized", true);

      // 解析原始 JSON 数据
      var initialData = [];
      try {
        if ($textarea.val()) {
          initialData = JSON.parse($textarea.val());
        }
      } catch (e) {
        console.warn("Invalid tableData JSON, fallback to empty:", e);
      }

      if (!Array.isArray(initialData) || initialData.length === 0) {
        // 默认给 5 x 5 空表
        initialData = Array.from({ length: 5 }, function () {
          return Array.from({ length: 5 }, function () {
            return "";
          });
        });
      }

      // 在 container 内渲染一个简单 table
      var $table = $("<table class='excel-like-table'></table>");
      var $tbody = $("<tbody></tbody>");

      initialData.forEach(function (row, rIndex) {
        var $tr = $("<tr></tr>");
        row.forEach(function (cell, cIndex) {
          var $td = $("<td contenteditable='true'></td>");
          $td.text(cell);

          // 保存位置信息
          $td.data("row", rIndex);
          $td.data("col", cIndex);

          $tr.append($td);
        });
        $tbody.append($tr);
      });

      $table.append($tbody);
      $container.empty().append($table);

      // 监听 cell 编辑 -> 写回数组 -> 写回 textarea(JSON)
      function syncToField() {
        var data = [];
        $tbody.find("tr").each(function (rIndex, tr) {
          var rowArr = [];
          $(tr)
            .find("td")
            .each(function (cIndex, td) {
              rowArr.push($(td).text());
            });
          data.push(rowArr);
        });

        $textarea.val(JSON.stringify(data));
      }

      // 编辑完成时同步
      $tbody.on("input blur", "td", function () {
        syncToField();
      });

      // 可选：增加行/列按钮
      var $toolbar = $("<div class='excel-table-toolbar'></div>");
      var $addRowBtn = $("<button type='button' class='coral-Button coral-Button--primary'>Add Row</button>");
      var $addColBtn = $("<button type='button' class='coral-Button coral-Button--secondary'>Add Column</button>");

      $addRowBtn.on("click", function () {
        var colCount =
          $tbody.find("tr:first-child td").length || 5;
        var $tr = $("<tr></tr>");
        for (var i = 0; i < colCount; i++) {
          var $td = $("<td contenteditable='true'></td>");
          $tr.append($td);
        }
        $tbody.append($tr);
        syncToField();
      });

      $addColBtn.on("click", function () {
        $tbody.find("tr").each(function () {
          var $td = $("<td contenteditable='true'></td>");
          $(this).append($td);
        });
        syncToField();
      });

      $toolbar.append($addRowBtn).append($addColBtn);
      $container.prepend($toolbar);

      // 初始同步一次
      syncToField();
    });
  }

  // dialog 打开时初始化
  $(document).on("dialog-ready", function () {
    initExcelEditors();
  });

})(document, Granite.$, Granite);
```

**重点：**

* 对话框打开时，找到 `textarea[name='./tableData']` 和前面的 `.excel-table-editor`；
* 把 JSON -> 二维数组 -> 渲染 author 用的“Excel table”；
* 任何改动（`input / blur`）回写 JSON 到 textarea；
* AEM 保存时，就把 `./tableData` 这个 JSON 存进 content 节点。

你以后只要把上面的“简易 Excel UI”替换成 Handsontable 初始化即可（同样的思路，change 回调里 `textarea.val(JSON.stringify(data))`）。

---

## 4. Sling Model + SPA Exporter（ui.apps）

我们用 Sling Model 把 `./tableData` 从 JSON 字符串解析成一个二维数组，导出给 React。

路径示例：

```text
/core/src/main/java/com/my/site/core/models/ExcelTableModel.java
```

**示例代码：**

```java
package com.my.site.core.models;

import com.adobe.cq.export.json.ComponentExporter;
import com.adobe.cq.export.json.ExportConstants;
import com.fasterxml.jackson.annotation.JsonProperty;
import org.apache.commons.lang3.StringUtils;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.models.annotations.DefaultInjectionStrategy;
import org.apache.sling.models.annotations.Exporter;
import org.apache.sling.models.annotations.Model;
import org.apache.sling.models.annotations.injectorspecific.ValueMapValue;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

@Model(
        adaptables = Resource.class,
        resourceType = "my-site/components/content/excel-table",
        adapters = {ExcelTableModel.class, ComponentExporter.class},
        defaultInjectionStrategy = DefaultInjectionStrategy.OPTIONAL
)
@Exporter(
        name = ExportConstants.EXPORTER_NAME,
        extensions = ExportConstants.EXPORTER_EXTENSION
)
public class ExcelTableModel implements ComponentExporter {

    @ValueMapValue
    private String tableData; // 存的就是上面 textarea 的 JSON

    @JsonProperty("tableData")
    public List<List<String>> getTableData() {
        List<List<String>> result = new ArrayList<>();
        if (StringUtils.isBlank(tableData)) {
            return result;
        }

        // 简单粗暴一点：用 Jackson 或 org.json 解析
        // 下面只是一个说明性示例，你实际项目里最好用 ObjectMapper

        try {
            com.fasterxml.jackson.databind.ObjectMapper mapper =
                    new com.fasterxml.jackson.databind.ObjectMapper();
            String[][] data = mapper.readValue(tableData, String[][].class);
            for (String[] row : data) {
                result.add(Arrays.asList(row));
            }
        } catch (Exception e) {
            // log error
        }
        return result;
    }

    @Override
    public String getExportedType() {
        return "my-site/components/content/excel-table";
    }
}
```

SPA Editor 导出的 JSON 大概会是：

```json
{
  "tableData": [
    ["A1", "B1", "C1"],
    ["A2", "B2", "C2"]
  ],
  ":type": "my-site/components/content/excel-table"
}
```

---

## 5. React 组件（ui.frontend）

在 `ui.frontend` 里，比如 `src/components/ExcelTable/ExcelTable.js`：

```js
// ui.frontend/src/components/ExcelTable/ExcelTable.js
import React from "react";
import { MapTo } from "@adobe/cq-react-editable-components";

const ExcelTable = (props) => {
  const data = props.tableData || [];

  if (!data.length) {
    // Author 模式下可以显示一个占位
    return <div className="excel-table-placeholder">No table data</div>;
  }

  return (
    <div className="excel-table">
      <table>
        <tbody>
          {data.map((row, rIdx) => (
            <tr key={rIdx}>
              {row.map((cell, cIdx) => (
                <td key={cIdx}>{cell}</td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

ExcelTable.editConfig = {
  emptyLabel: "Excel Table",
  isEmpty: (props) =>
    !props || !props.tableData || props.tableData.length === 0,
};

export default MapTo("my-site/components/content/excel-table")(ExcelTable);
```

如需复杂渲染（例如第一行/列为表头、某些列是数字对齐、某些单元格有链接等），都可以基于 `tableData` 做二次处理。

---

## 6. 项目串联小结

1. **Author 侧（对话框）**

   * `extraClientlibs` 引入 `my-site.excel-table.author`；
   * clientlib JS 找到 `./tableData` 字段和 `.excel-table-editor`；
   * 用简易表格或 Handsontable 提供 Excel 样的编辑体验；
   * 改动 → JSON 写回 textarea → AEM 保存在 jcr 节点。

2. **后端导出**

   * Sling Model `ExcelTableModel` 读取 `tableData` 字符串；
   * 解析 JSON → `List<List<String>>`；
   * 通过 SPA Exporter 输出给 React。

3. **React 渲染**

   * `ExcelTable` 组件从 props 中拿 `tableData`；
   * 按你的样式渲染 `<table>`（完全可以和对话框里的 UI 不同）。

---

如果你愿意具体用某个库（例如 Handsontable / AG Grid / Tabulator），我可以帮你把上面的简易 JS 改成对应库的初始化代码（包含如何从库里拿数据 -> JSON 回写到 `./tableData`）。
